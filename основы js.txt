    • Что такое «строгий режим»? Для чего он нужен?
Режим позволяющий использовать более строгий синтаксис JS. Изначально JS рассчитывался как язык с низким порогом вхождения и имел более свободный синатксис, что приводило к ошибкам и проблемам с поддержкой кода, строгий режим помогает их в некоторой мере избежать. 


    • Переменные – в чем отличие var, let, const? Когда и что предпочтительнее применять? 

    Переменные заданные с помощью var имеют большую область видимости; инициализируются значением undefined даже если к ним обращаются до того, как они будут объявлены. 
 Заданные с помощью let имеют меньшую область видимости, запрос до объявления переменной вызовет ошибку.
Примитивные типы заданные через const имеют константное (неизменное) значение, однако есть проблемы с иммутабельностью объектов. 
       Когда и что применять?
var рационально применять для приложений, которые рассчитаны на поддержку старыми браузерами, в остальном же лучше от var воздержаться. 
let стоит использовать для всех переменных, за исключением необходимых констант. 
const стоит использовать для переменных, которые должны оставаться неизменными.


• Операторы сравнения 

    o в чем отличие `==` от `===`; `!=` от `!==`?  
        операторы == и != приводят типы сравниваемых значений к одному, что не делают операторы === и !==. 

    o Что будет в результате: '01' == 1 и '01' === 1? Почему?
        true и false соотвественно. В первом случае значения будт приведены к одному типу, во втором случае нет. 

    o Что будет в результате: null === undefined и null == undefined? Почему? 
        false и true соответсвенно. null и undefined формируют тип из самого себя, но оба означают отсутсвие значения переменной. 

    o Что будет в результате: null > 0; null == 0; null >= 0? Почему? 
        false во всех за исключением третьего случая.  
    Операторы сравнения для того, чтобы выяснить истинно ли выражение, пропускают его через "абстрактный алгоритм сравнения для отношений" , где происходят преобразования одних типов данных     к другим, в результате null преобразуется к значению "+0", а 0 в результате преобразований остаётся неизменным. Значение +0 = 0, поэтому:
    null > 0;
    null < 0; 
    вернут два раза false. 

Для равенств алгоритм сравнения другой, в котором null не попадает ни под одно преобразование, после чего false возвращается по умолчанию, поэтому null == 0.
Выражение null >= 0 попадает под первый алгоритм в результате сравнение возвращает true. 	

    o Что будет в результате: undefined > 0; undefined < 0; undefined == 0? Почему? 
 undefined преобразуется к значению NaN в результате сравнения дают ложный результат. 


    • Функции: можно ли сохранить функцию в переменную? 
    Да. 

    • Функции колбэки: Напишите функцию, которая реализует подтверждение опредленного действия (например, вы точно хотите удалить выбранный элемент?) в качестве параметров фукнция должна принимать: вопрос; функцию-колбэк, вызываемую если пользователь подтвердит действие; функциюколбэк, вызываемую если пользователь отклонит действие. Для подтверждения пользователем – используйте стандартную функцию prompt.

function deleteElement() {
  //какая-то функциональность
  return alert("удалено");
}

function confirmQuestion(question, callback) {
  if (confirm(question)) {
    return callback();
  } else return null;
}



    • Объекты, методы объектов, this. Что такое this? Приведите пример потери this; Приведите пример решения проблемы потери this через привязку контекста и стрелочные функции
     this - ключевое слово, которое служит для привязки контекста вызова функции. 
    
    this.x = 5;
    let obj = {
   x: 10,
  getX: function() {return this.x}
};
let getX=obj.getX;
getX() // 5, this ссылается на глобальный объект
let bindGetX = getX.bind(obj)
bindGetX() // 10, this ссылается на объект obj
arrowGetX = () => obj.getX(); // 10
arrowGetX()

    • Планирование: setTimeout и setInterval. Для чего они используются? В чем отличие setIntercal от рекурсивного setTimeout? Отмена timeout-а и interval-а. 
    Для отложенного вызова функции. setTimeout вызывает функцию один раз, setInterval вызывает функцию через интервал. 
через методы сlearTimeout и clearInterval соответственно.  